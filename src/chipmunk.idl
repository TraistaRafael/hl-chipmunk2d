
// ---------------------------------------------------------------------------------------------------------
// chipmunk_types.h
//----------------------------------------------------------------------------------------------------------
typedef cpFloat double;
typedef cpBool uchar;
typedef cpDataPointer VoidPtr;
typedef cpGroup int64;
typedef cpBitmask uint;

interface cpVect
{
	void cpVect();
	attribute cpFloat x;
    attribute cpFloat y;
};

interface cpTransform {
	void cpTransform();
	attribute cpFloat a;
	attribute cpFloat b;
	attribute cpFloat c;
	attribute cpFloat d;
	attribute cpFloat tx; 
	attribute cpFloat ty;
};

interface cpMat2x2 {
	void cpMat2x2();
	attribute cpFloat a; 
	attribute cpFloat b;
	attribute cpFloat c;
	attribute cpFloat d;
};


// ---------------------------------------------------------------------------------------------------------
// cpBB.h
//----------------------------------------------------------------------------------------------------------
interface cpBB
{
    void cpBB();
    attribute cpFloat l;
    attribute cpFloat b;
    attribute cpFloat r;
    attribute cpFloat t;
	
	[Static,AddressOf] cpBB cpBBNew([Const] cpFloat l, [Const] cpFloat b, [Const] cpFloat r, [Const] cpFloat t);
	[Static,AddressOf] cpBB cpBBNewForExtents([Const,Deref] cpVect c, [Const] cpFloat hw, [Const] cpFloat hh);
	[Static,AddressOf] cpBB cpBBNewForCircle([Const,Deref] cpVect p, [Const] cpFloat r);
	[Static] cpBool cpBBIntersects([Const,Deref] cpBB a, [Const,Deref] cpBB b);
	[Static] cpBool cpBBContainsBB([Const,Deref] cpBB bb, [Const,Deref] cpBB other);
	[Static] cpBool cpBBContainsVect([Const,Deref] cpBB bb, [Const,Deref] cpVect v);
	[Static,AddressOf] cpBB cpBBMerge([Const,Deref] cpBB a, [Const,Deref] cpBB b);
	[Static,AddressOf] cpBB cpBBExpand([Const,Deref] cpBB bb, [Const,Deref] cpVect v);
	[Static,AddressOf] cpVect cpBBCenter([Deref] cpBB bb);
	[Static] cpFloat cpBBArea([Deref] cpBB bb);
	[Static] cpFloat cpBBMergedArea([Deref] cpBB a, [Deref] cpBB b);
	[Static] cpFloat cpBBSegmentQuery([Deref] cpBB bb, [Deref] cpVect a, [Deref] cpVect b);
	[Static] cpBool cpBBIntersectsSegment([Deref] cpBB bb, [Deref] cpVect a, [Deref] cpVect b);
	[Static,AddressOf] cpVect cpBBClampVect([Const,Deref] cpBB bb, [Const,Deref] cpVect v);
	[Static,AddressOf] cpVect cpBBWrapVect([Const,Deref] cpBB bb, [Const,Deref] cpVect v);
	[Static,AddressOf] cpBB cpBBOffset([Const,Deref] cpBB bb, [Const,Deref] cpVect v);
};


// ---------------------------------------------------------------------------------------------------------
// cpBody.h
//----------------------------------------------------------------------------------------------------------
// enum cpBodyTypeHL {
// 	"CP_BODY_TYPE_DYNAMIC",
// 	"CP_BODY_TYPE_KINEMATIC",
// 	"CP_BODY_TYPE_STATIC"
// };

[Internal="cpBody"]	
interface cpBody {
	
	void cpBody();

	[Static] cpBody cpBodyAlloc();

	[Static] cpBody cpBodyInit(cpBody body, cpFloat mass, cpFloat moment);

	[Static] cpBody cpBodyNew(cpFloat mass, cpFloat moment);

	[Static] cpBody cpBodyNewKinematic();

	[Static] cpBody cpBodyNewStatic();

	[CObject] void cpBodyDestroy();
	
	[CObject] void cpBodyFree();

	[CObject] void cpBodyActivate();

	//[CObject] void cpBodyActivateStatic( cpShape filter);

	[CObject] void cpBodySleep();

	[CObject] void cpBodySleepWithGroup(cpBody group);

	[CObject] cpBool cpBodyIsSleeping();

	//[CObject] cpBodyType cpBodyGetType();

	//[CObject] void cpBodySetType(cpBodyType type);

	// [CObject] cpSpace cpBodyGetSpace();

	[CObject] cpFloat cpBodyGetMass();

	[CObject] void cpBodySetMass(cpFloat m);

	[CObject] cpFloat cpBodyGetMoment();

	[CObject] void cpBodySetMoment(cpFloat i);

	[CObject,AddressOf] cpVect cpBodyGetPosition();

	[CObject] void cpBodySetPosition([Deref] cpVect pos);

	[CObject,AddressOf] cpVect cpBodyGetCenterOfGravity();
	
	[CObject] void cpBodySetCenterOfGravity([Deref] cpVect cog);

	[CObject,AddressOf] cpVect cpBodyGetVelocity();

	[CObject] void cpBodySetVelocity([Deref] cpVect velocity);

	[CObject,AddressOf] cpVect cpBodyGetForce();

	[CObject] void cpBodySetForce([Deref] cpVect force);

	[CObject] cpFloat cpBodyGetAngle();

	[CObject] void cpBodySetAngle(cpFloat a);

	[CObject] cpFloat cpBodyGetAngularVelocity();

	[CObject] void cpBodySetAngularVelocity(cpFloat angularVelocity);

	[CObject] cpFloat cpBodyGetTorque();

	[CObject] void cpBodySetTorque(cpFloat torque);

	[CObject,AddressOf] cpVect cpBodyGetRotation();

	//[CObject] cpDataPointer cpBodyGetUserData();

	//[CObject] void cpBodySetUserData(cpDataPointer userData);

	// [CObject] void cpBodySetVelocityUpdateFunc(cpBodyVelocityFunc velocityFunc); // TODO

	// [CObject] void cpBodySetPositionUpdateFunc(cpBodyPositionFunc positionFunc); // TODO

	[CObject] void cpBodyUpdateVelocity([Deref] cpVect gravity, cpFloat damping, cpFloat dt);
	
	[CObject] void cpBodyUpdatePosition(cpFloat dt);

	[CObject,AddressOf] cpVect cpBodyLocalToWorld([Const,Deref] cpVect point);

	[CObject,AddressOf] cpVect cpBodyWorldToLocal([Const,Deref] cpVect point);

	[CObject] void cpBodyApplyForceAtWorldPoint([Deref] cpVect force, [Deref] cpVect point);

	[CObject] void cpBodyApplyForceAtLocalPoint([Deref] cpVect force, [Deref] cpVect point);

	[CObject] void cpBodyApplyImpulseAtWorldPoint([Deref] cpVect impulse, [Deref] cpVect point);
	
	[CObject] void cpBodyApplyImpulseAtLocalPoint([Deref] cpVect impulse, [Deref] cpVect point);

	[CObject,AddressOf] cpVect cpBodyGetVelocityAtWorldPoint([Deref] cpVect point);
	
	[CObject,AddressOf]  cpVect cpBodyGetVelocityAtLocalPoint([Deref] cpVect point);

	[CObject] cpFloat cpBodyKineticEnergy();

	// TODO
	// [CObject] void cpBodyEachShape(cpBodyShapeIteratorFunc func, void *data);

	// [CObject] void cpBodyEachConstraint(cpBodyConstraintIteratorFunc func, void *data);

	// [CObject] void cpBodyEachArbiter(cpBodyArbiterIteratorFunc func, void *data);
};


// ---------------------------------------------------------------------------------------------------------
// cpShape.h
//----------------------------------------------------------------------------------------------------------

interface cpPointQueryInfo 
{
	void cpPointQueryInfo();
	[Const] attribute cpShape shape;
	[Value] attribute cpVect point;
	attribute cpFloat distance;
	[Value] attribute cpVect gradient;
};

interface cpSegmentQueryInfo {
	void cpSegmentQueryInfo();
	[Const] attribute cpShape shape;
	[Value] attribute cpVect point;
	[Value] attribute cpVect normal;
	attribute cpFloat alpha;
};

interface cpShapeFilter {
	attribute cpGroup group;
	attribute cpBitmask categories;
	attribute cpBitmask mask;
};

interface cpShape
{
	void cpShape();

	[Static,AddressOf] cpShapeFilter cpShapeFilterNew(cpGroup group, cpBitmask categories, cpBitmask mask);

	[CObject] void cpShapeDestroy();

	[CObject] void cpShapeFree();

	[CObject,AddressOf] cpBB cpShapeCacheBB();

	[CObject,AddressOf] cpBB cpShapeUpdate([Deref] cpTransform transform);

	[CObject] cpFloat cpShapePointQuery([Deref] cpVect p, cpPointQueryInfo out);

	[CObject] cpBool cpShapeSegmentQuery([Deref] cpVect a, [Deref] cpVect b, cpFloat radius, cpSegmentQueryInfo info);

	[Static,AddressOf] cpContactPointSet cpShapesCollide([Const] cpShape a, [Const] cpShape b);

	[CObject] cpSpace cpShapeGetSpace();

	[CObject] cpBody cpShapeGetBody();

	[CObject] void cpShapeSetBody(cpBody body);

	[CObject] cpFloat cpShapeGetMass();

	[CObject] void cpShapeSetMass(cpFloat mass);

	[CObject] cpFloat cpShapeGetDensity();

	[CObject] void cpShapeSetDensity(cpFloat density);

	[CObject] cpFloat cpShapeGetMoment();

	[CObject] cpFloat cpShapeGetArea();

	[CObject,AddressOf] cpVect cpShapeGetCenterOfGravity();

	[CObject,AddressOf] cpBB cpShapeGetBB();

	[CObject] cpBool cpShapeGetSensor();

	[CObject] void cpShapeSetSensor(cpBool sensor);

	[CObject] cpFloat cpShapeGetElasticity();

	[CObject] void cpShapeSetElasticity(cpFloat elasticity);

	[CObject] cpFloat cpShapeGetFriction();

	[CObject] void cpShapeSetFriction(cpFloat friction);

	[CObject,AddressOf] cpVect cpShapeGetSurfaceVelocity();

	[CObject] void cpShapeSetSurfaceVelocity([Deref] cpVect surfaceVelocity);

	[CObject] cpDataPointer cpShapeGetUserData();

	[CObject] void cpShapeSetUserData(cpDataPointer userData);

	// [CObject] cpCollisionType cpShapeGetCollisionType();

	// [CObject] void cpShapeSetCollisionType(cpCollisionType collisionType);

	[CObject,AddressOf] cpShapeFilter cpShapeGetFilter();

	[CObject] void cpShapeSetFilter([Deref] cpShapeFilter filter);
};

interface cpCircleShape
{
	
}

// ---------------------------------------------------------------------------------------------------------
// cpSpace.h
//----------------------------------------------------------------------------------------------------------
interface cpSpace
{
	
};


// ---------------------------------------------------------------------------------------------------------
// cpArbiter.h
//----------------------------------------------------------------------------------------------------------
interface cpContactPointSet {
	/// The number of contact points in the set.
	// int count;
	
	// cpVect normal;
	
	// /// The array of contact points.
	// struct {
	// 	/// The position of the contact on the surface of each shape.
	// 	cpVect pointA, pointB;
	// 	/// Penetration distance of the two shapes. Overlapping means it will be negative.
	// 	/// This value is calculated as cpvdot(cpvsub(point2, point1), normal) and is ignored by cpArbiterSetContactPointSet().
	// 	cpFloat distance;
	// } points[CP_MAX_CONTACTS_PER_ARBITER];
};

// ---------------------------------------------------------------------------------------------------------
// chipmunk.h
//----------------------------------------------------------------------------------------------------------
interface Chipmunk2D 
{
	[Static] cpFloat cpMomentForCircle(cpFloat m, cpFloat r1, cpFloat r2, [Deref] cpVect offset);

	[Static] cpFloat cpAreaForCircle(cpFloat r1, cpFloat r2);
	
	[Static] cpFloat cpMomentForSegment(cpFloat m, [Deref,Cast="cpVect*"] cpVect a, [Deref] cpVect b, cpFloat radius);
	
	[Static] cpFloat cpMomentForPoly( cpFloat m, int count, [Const,Cast="cpVect*"] double[] verts, 
							[Deref] cpVect offset, cpFloat radius);

	[Static] cpFloat cpAreaForSegment([Deref] cpVect a, [Deref] cpVect b, cpFloat radius);

	[Static] cpFloat cpAreaForPoly([Const] int count, [Const,Cast="cpVect*"] double[] verts, cpFloat radius);

	[Static,AddressOf] cpVect cpCentroidForPoly([Const] int count, [Cast="cpVect*"] double[] verts);

	[Static] cpFloat cpMomentForBox(cpFloat m, cpFloat width, cpFloat height);

	[Static] cpFloat cpMomentForBox2(cpFloat m, [Deref] cpBB box);

	[Static] int cpConvexHull(int count,  [Const,Cast="cpVect*"] double[] verts, 
							[Cast="cpVect*"] double[] result, int[] first, cpFloat tol);

	[Static,AddressOf] cpVect cpClosetPointOnSegment( [Deref] cpVect p, 
							 [Deref] cpVect a, [Deref] cpVect b);


};
